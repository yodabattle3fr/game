<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bounce Brawl â€” Local Party Game</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --muted:#9aa8bf;
    --accent: #6ee7b7;
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{
    background: linear-gradient(180deg,#071021 0%, #0f1724 100%);
    color:#e6eef8;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:18px;
  }
  .wrap{
    width:100%;
    max-width:1100px;
    display:grid;
    grid-template-columns:1fr 320px;
    gap:18px;
  }
  #game {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    border-radius:14px;
    padding:14px;
    box-shadow: 0 10px 30px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
  }
  canvas{
    display:block;
    width: 100%;
    height: calc(100vh - 160px);
    min-height:480px;
    background: radial-gradient(800px 400px at 20% 20%, rgba(255,255,255,0.02), transparent 5%),
                radial-gradient(700px 350px at 80% 80%, rgba(255,255,255,0.01), transparent 3%),
                linear-gradient(180deg, rgba(255,255,255,0.005), transparent),
                #071427;
    border-radius:10px;
  }
  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    border-radius:12px;
    padding:14px;
    color:var(--muted);
    min-height:480px;
  }
  h1{margin:0 0 10px 0; font-size:20px; color:#dff7ea}
  .row{display:flex;gap:8px;align-items:center;justify-content:space-between}
  .controls{margin-top:10px;font-size:13px; color:var(--muted)}
  button{
    background:#0b1526;border:1px solid rgba(255,255,255,0.04);color:var(--accent);
    padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600;
  }
  button.secondary{
    background:transparent;color:var(--muted);
    border:1px dashed rgba(255,255,255,0.03);
  }
  .player-list{margin-top:12px;display:grid;gap:8px}
  .player-item{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:linear-gradient(90deg, rgba(255,255,255,0.01), transparent);font-size:14px}
  .muted{color:var(--muted);font-size:13px}
  .big{font-size:18px;color:#dff7ea}
  footer{margin-top:12px;font-size:12px;color:var(--muted)}
  .hint{font-size:13px;color:var(--muted);margin-top:8px}
  .flexcol{display:flex;flex-direction:column}
  .small{font-size:13px}
  .center{display:flex;align-items:center;gap:8px}
  .score-pill{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:999px;color:var(--accent);font-weight:600}
  @media (max-width:1000px){
    .wrap{grid-template-columns:1fr}
    canvas{height:460px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div id="game">
    <canvas id="c"></canvas>
    <div style="display:flex;gap:8px;margin-top:8px;align-items:center;justify-content:space-between">
      <div class="center">
        <div class="muted">Mode:</div>
        <div class="score-pill" id="modeLabel">Race to 12</div>
      </div>
      <div class="center">
        <div class="muted">Time:</div>
        <div class="score-pill" id="timeLabel">--:--</div>
      </div>
      <div style="display:flex;gap:8px">
        <button id="pauseBtn">Pause</button>
        <button id="restartBtn" class="secondary">Restart</button>
      </div>
    </div>
  </div>

  <aside class="panel">
    <h1>Bounce Brawl</h1>
    <div class="muted">Local 2â€“4 player arena party game. Collect coins, steal points, and use powerups!</div>

    <div style="margin-top:12px" class="row">
      <div>
        <div class="small muted">Players</div>
        <div class="big" id="playersCount">2</div>
      </div>
      <div>
        <div class="small muted">Score limit</div>
        <div class="big" id="scoreLimitLabel">12</div>
      </div>
    </div>

    <div class="player-list" id="playerList">
      <!-- populated by JS -->
    </div>

    <div class="controls">
      <div style="margin-top:10px">
        <button id="addPlayer">Add Player</button>
        <button id="removePlayer" class="secondary">Remove Player</button>
      </div>
      <div class="hint">Controls per player (keyboard):</div>
      <div class="hint small" style="margin-top:6px">
        <strong>Player 1:</strong> WASD &nbsp; â€¢ &nbsp;
        <strong>Player 2:</strong> Arrow keys &nbsp; â€¢ &nbsp;
        <strong>Player 3:</strong> IJKL &nbsp; â€¢ &nbsp;
        <strong>Player 4:</strong> TFGH
      </div>

      <div style="margin-top:12px">
        <div class="muted">Rules</div>
        <ul style="color:var(--muted);margin:8px 0 0 16px;padding:0">
          <li>Collect coins (+1).</li>
          <li>Bumping a player briefly steals 1 coin (if they have one).</li>
          <li>Powerups spawn: speed, shield, magnet.</li>
          <li>First to score limit wins â€” or highest after timer ends.</li>
        </ul>
      </div>

<div id="ownerPanel" style="display:none; margin-top:14px; padding:10px; border-radius:10px; background:rgba(255,255,255,0.03)">
  <div style="color:#f87171; font-weight:700; margin-bottom:6px">Owner Panel</div>
  <button onclick="ownerTools.instaWin()">Insta Win</button>
  <button onclick="ownerTools.addCoins()">+10 Coins (P1)</button>
  <button onclick="ownerTools.spawnCoins()">Spawn 20 Coins</button>
  <button onclick="ownerTools.toggleChaos()">Toggle Chaos Mode</button>
</div>

      
      <footer>
        <div style="margin-top:12px"><strong class="muted">Tip:</strong> Play with friends and chaos! You can also hold a controller per player if you edit keys in the code.</div>
      </footer>
    </div>
  </aside>
</div>

<script>
// === Owner Tools ===
const ownerTools = {
  active: false,
  chaos: false,
  instaWin(){
    state.winner = state.players[0]; // force Player 1 win
    playBeep(300, 0.6);
  },
  addCoins(){
    state.players[0].coins += 10;
    playBeep(1200,0.2);
  },
  spawnCoins(){
    for(let i=0;i<20;i++) spawnCoin();
  },
  toggleChaos(){
    this.chaos = !this.chaos;
    if(this.chaos){
      state.players.forEach(p => p.speed *= 2);
      powerupSpawnTimer = 1;
    } else {
      state.players.forEach(p => p.speed = 0.24);
    }
  }
};

// Secret activation
function unlockOwnerPanel(){
  const pass = prompt("Enter owner password:");
  if(pass === "mySecret123"){ // <<< change this
    document.getElementById('ownerPanel').style.display = 'block';
    ownerTools.active = true;
    alert("Owner panel unlocked!");
  } else {
    alert("Access denied.");
  }
}

// Shortcut key: Shift+O
window.addEventListener('keydown', e => {
  if(e.shiftKey && e.key.toLowerCase()==="o" && !ownerTools.active){
    unlockOwnerPanel();
  }
});

  
  /*
 Bounce Brawl â€” Single-file local multiplayer party game
 Controls:
  Player 1: W A S D
  Player 2: Arrow keys
  Player 3: I J K L
  Player 4: T F G H

 How to use:
  - Save as bounce-brawl.html and open in a modern browser.
  - Add/remove players with the sidebar buttons.
  - Pause / Restart as needed.
*/

(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  let W = 1200, H = 700;
  function resize() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(800, Math.floor(rect.width * devicePixelRatio));
    canvas.height = Math.max(480, Math.floor(rect.height * devicePixelRatio));
    W = canvas.width; H = canvas.height;
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Utility
  function rand(min, max){ return Math.random()*(max-min)+min }
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)) }
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y) }

  // Game constants
  const COLORS = ['#4ade80','#60a5fa','#f472b6','#fbbf24'];
  const PLAYER_CONTROLS = [
    { up:'w', down:'s', left:'a', right:'d' },
    { up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight' },
    { up:'i', down:'k', left:'j', right:'l' },
    { up:'t', down:'g', left:'f', right:'h' }
  ];

  // State and classes
  class Player {
    constructor(id, x, y, color) {
      this.id = id;
      this.x = x; this.y = y;
      this.r = 20;
      this.color = color;
      this.vx = 0; this.vy = 0;
      this.speed = 0.24;
      this.friction = 0.98;
      this.score = 0;
      this.coins = 0;
      this.shield = 0; // frames
      this.magnet = 0; // frames
      this.speedBoost = 0;
      this.name = `P${id+1}`;
      this.alive = true;
      this.controlLock = false;
    }
    update(dt, keys) {
      if (!this.alive) return;
      let ax = 0, ay = 0;
      if (!this.controlLock) {
        if (keys[PLAYER_CONTROLS[this.id].up]) ay -= 1;
        if (keys[PLAYER_CONTROLS[this.id].down]) ay += 1;
        if (keys[PLAYER_CONTROLS[this.id].left]) ax -= 1;
        if (keys[PLAYER_CONTROLS[this.id].right]) ax += 1;
      }
      const mag = Math.hypot(ax,ay);
      if (mag > 0) {
        ax /= mag; ay /= mag;
        const sp = this.speed * (this.speedBoost ? 2.0 : 1.0);
        this.vx += ax * sp * dt;
        this.vy += ay * sp * dt;
      } else {
        // natural friction
        this.vx *= Math.pow(this.friction, dt*60);
        this.vy *= Math.pow(this.friction, dt*60);
      }
      // clamp speed
      const maxVel = 10 * (this.speedBoost ? 2 : 1);
      const vmag = Math.hypot(this.vx, this.vy);
      if (vmag > maxVel) {
        this.vx = this.vx / vmag * maxVel;
        this.vy = this.vy / vmag * maxVel;
      }
      this.x += this.vx * dt;
      this.y += this.vy * dt;

      // bounds
      if (this.x < this.r) { this.x = this.r; this.vx *= -0.3; }
      if (this.x > canvas.width/devicePixelRatio - this.r) { this.x = canvas.width/devicePixelRatio - this.r; this.vx *= -0.3; }
      if (this.y < this.r) { this.y = this.r; this.vy *= -0.3; }
      if (this.y > canvas.height/devicePixelRatio - this.r) { this.y = canvas.height/devicePixelRatio - this.r; this.vy *= -0.3; }

      // timers
      if (this.shield > 0) this.shield = Math.max(0, this.shield - dt*60);
      if (this.magnet > 0) this.magnet = Math.max(0, this.magnet - dt*60);
      if (this.speedBoost > 0) this.speedBoost = Math.max(0, this.speedBoost - dt*60);
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      // shadow
      ctx.beginPath();
      ctx.ellipse(0, this.r*0.75, this.r*1.1, this.r*0.5, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fill();

      // ball
      ctx.beginPath();
      ctx.arc(0, -4, this.r, 0, Math.PI*2);
      const g = ctx.createLinearGradient(-this.r, -this.r-6, this.r, this.r+6);
      g.addColorStop(0, tinyColor(this.color, 0.9));
      g.addColorStop(1, tinyColor(this.color, 1.15));
      ctx.fillStyle = g;
      ctx.fill();

      // border
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.stroke();

      // shield ring
      if (this.shield > 0) {
        ctx.beginPath();
        ctx.arc(0, -4, this.r + 6, 0, Math.PI*2);
        ctx.lineWidth = 4;
        ctx.strokeStyle = `rgba(180,220,255,${0.6})`;
        ctx.stroke();
      }

      // id text
      ctx.fillStyle = '#02121b';
      ctx.font = '700 12px Inter, Arial';
      ctx.textAlign = 'center';
      ctx.fillText(this.name, 0, 6 - 4);
      ctx.restore();
    }
  }

  class Coin {
    constructor(x,y){
      this.x = x; this.y = y; this.r = 10;
      this.collected = false;
      this.pulse = Math.random()*Math.PI*2;
    }
    update(dt){ this.pulse += dt*6; }
    draw(ctx){
      ctx.save();
      ctx.translate(this.x, this.y);
      const s = 1 + Math.sin(this.pulse)*0.06;
      ctx.beginPath();
      ctx.ellipse(0,0,this.r*s,this.r*s,0,0,Math.PI*2);
      ctx.fillStyle = '#FFD166';
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.stroke();
      ctx.restore();
    }
  }

  class Powerup {
    constructor(x,y,type){
      this.x = x; this.y = y; this.r = 14;
      this.type = type; // 'speed','shield','magnet'
      this.life = 12*60; // frames
      this.pulse = 0;
    }
    update(dt){ this.pulse += dt*6; this.life -= dt*60; }
    draw(ctx){
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.beginPath();
      ctx.arc(0,0,this.r + Math.sin(this.pulse)*2,0,Math.PI*2);
      ctx.fillStyle = this.type === 'speed' ? '#60a5fa' : (this.type === 'shield' ? '#93c5fd' : '#7c3aed');
      ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '700 12px Inter, Arial';
      ctx.textAlign = 'center';
      if (this.type === 'speed') ctx.fillText('âš¡',0,4);
      if (this.type === 'shield') ctx.fillText('ðŸ›¡',0,4);
      if (this.type === 'magnet') ctx.fillText('ðŸ§²',0,4);
      ctx.restore();
    }
  }

  function tinyColor(hex, factor){
    // simple brighten/darken
    const c = hex.replace('#','');
    const r = Math.min(255, Math.max(0, parseInt(c.slice(0,2),16)*factor|0));
    const g = Math.min(255, Math.max(0, parseInt(c.slice(2,4),16)*factor|0));
    const b = Math.min(255, Math.max(0, parseInt(c.slice(4,6),16)*factor|0));
    return `rgb(${r},${g},${b})`;
  }

  // Main Game
  const state = {
    players: [],
    coins: [],
    powerups: [],
    keys: {},
    lastTime: performance.now(),
    running: true,
    timeLeft: 180, // seconds
    scoreLimit: 12,
    mode: 'race', // or 'timed'
    winner: null,
    paused: false
  };

  // Input
  window.addEventListener('keydown', e => { state.keys[e.key] = true; if (e.key === ' ') e.preventDefault(); });
  window.addEventListener('keyup', e => { state.keys[e.key] = false; });

  // UI hooks
  const playersCountLabel = document.getElementById('playersCount');
  const playerListEl = document.getElementById('playerList');
  const timeLabel = document.getElementById('timeLabel');
  const modeLabel = document.getElementById('modeLabel');
  const scoreLimitLabel = document.getElementById('scoreLimitLabel');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const addBtn = document.getElementById('addPlayer');
  const removeBtn = document.getElementById('removePlayer');

  pauseBtn.onclick = () => {
    state.paused = !state.paused;
    pauseBtn.textContent = state.paused ? 'Resume' : 'Pause';
  };
  restartBtn.onclick = () => resetGame();
  addBtn.onclick = () => { if (state.players.length < 4) { addPlayer(); } };
  removeBtn.onclick = () => { if (state.players.length > 2) { removePlayer(); } };

  function addPlayer(){
    const id = state.players.length;
    const x = rand(80, canvas.width/devicePixelRatio - 80);
    const y = rand(80, canvas.height/devicePixelRatio - 80);
    const p = new Player(id, x, y, COLORS[id]);
    p.name = `P${id+1}`;
    state.players.push(p);
    updatePlayerList();
  }
  function removePlayer(){
    state.players.pop();
    updatePlayerList();
  }

  function updatePlayerList(){
    playersCountLabel.textContent = state.players.length;
    playerListEl.innerHTML = '';
    state.players.forEach(p => {
      const div = document.createElement('div');
      div.className = 'player-item';
      div.innerHTML = `<div style="display:flex;align-items:center;gap:10px">
        <div style="width:18px;height:18px;border-radius:6px;background:${p.color};box-shadow:0 2px 8px rgba(0,0,0,0.4)"></div>
        <div><strong style="color:#dff7ea">${p.name}</strong><div class="muted small">Coins: <span id="c${p.id}">${p.coins}</span></div></div>
      </div>
      <div style="text-align:right"><div style="font-weight:700;color:var(--accent)">${p.score}</div></div>`;
      playerListEl.appendChild(div);
    });
    scoreLimitLabel.textContent = state.scoreLimit;
    modeLabel.textContent = state.mode === 'race' ? `Race to ${state.scoreLimit}` : 'Timed Mode';
  }

  // spawn helpers
  function spawnCoin(){
    for (let i=0;i<50;i++){
      const x = rand(60, canvas.width/devicePixelRatio - 60);
      const y = rand(60, canvas.height/devicePixelRatio - 60);
      // ensure not inside player
      if (!state.players.some(p => Math.hypot(p.x-x,p.y-y) < p.r + 30)) {
        state.coins.push(new Coin(x,y));
        return;
      }
    }
  }
  function spawnPowerup(){
    const types = ['speed','shield','magnet'];
    const t = types[Math.floor(Math.random()*types.length)];
    const x = rand(80, canvas.width/devicePixelRatio - 80);
    const y = rand(80, canvas.height/devicePixelRatio - 80);
    state.powerups.push(new Powerup(x,y,t));
  }

  // collision resolution: player vs player simple elastic-ish
  function handlePlayerCollisions(){
    for (let i=0;i<state.players.length;i++){
      for (let j=i+1;j<state.players.length;j++){
        const A = state.players[i], B = state.players[j];
        if (!A.alive || !B.alive) continue;
        const dx = B.x - A.x, dy = B.y - A.y;
        const d = Math.hypot(dx,dy);
        const minD = A.r + B.r;
        if (d > 0 && d < minD) {
          const overlap = (minD - d) * 0.5;
          const nx = dx / d, ny = dy / d;
          A.x -= nx * overlap;
          A.y -= ny * overlap;
          B.x += nx * overlap;
          B.y += ny * overlap;
          // simple exchange of velocity component along normal
          const rel = (B.vx - A.vx) * nx + (B.vy - A.vy) * ny;
          const impulse = rel * 1.0;
          A.vx += nx * impulse * 0.7;
          A.vy += ny * impulse * 0.7;
          B.vx -= nx * impulse * 0.7;
          B.vy -= ny * impulse * 0.7;

          // bump event: steal coin if attacker has momentum and victim has coins
          const speed = Math.hypot(B.vx - A.vx, B.vy - A.vy);
          if (speed > 3) {
            // the faster one takes from the slower
            let taker = (Math.hypot(A.vx,A.vy) > Math.hypot(B.vx,B.vy)) ? A : B;
            let giver = taker === A ? B : A;
            if (taker && giver.coins > 0 && giver.shield <= 0) {
              giver.coins = Math.max(0, giver.coins - 1);
              taker.coins += 1;
              // little feedback
              playBeep(880, 0.06);
            }
          }
        }
      }
    }
  }

  // game loop
  let coinSpawnTimer = 0;
  let powerupSpawnTimer = 10; // seconds

  function resetGame(){
    // reset players and items
    state.coins = [];
    state.powerups = [];
    state.timeLeft = 180;
    state.winner = null;
    state.paused = false;
    coinSpawnTimer = 0;
    powerupSpawnTimer = 10;
    // reposition players
    state.players.forEach((p, i) => {
      p.x = rand(80, canvas.width/devicePixelRatio - 80);
      p.y = rand(80, canvas.height/devicePixelRatio - 80);
      p.vx = p.vy = 0;
      p.score = 0; p.coins = 0;
      p.shield = p.magnet = p.speedBoost = 0;
    });
    // initial coins
    for (let i=0;i<8;i++) spawnCoin();
    updatePlayerList();
  }

  // audio: simple beep
  const audioCtx = (typeof AudioContext !== 'undefined') ? new AudioContext() : null;
  function playBeep(freq=440,duration=0.08, type='sine'){
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    o.connect(g);
    g.connect(audioCtx.destination);
    g.gain.value = 0.0001;
    const t = audioCtx.currentTime;
    g.gain.linearRampToValueAtTime(0.12, t + 0.01);
    o.start(t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + duration);
    o.stop(t + duration + 0.02);
  }

  function awardCoinTo(p, coin){
    p.coins += 1;
    state.coins = state.coins.filter(c => c !== coin);
    playBeep(1200, 0.06);
  }

  function update(dt){
    if (state.paused || state.winner) return;
    // timers
    state.timeLeft = Math.max(0, state.timeLeft - dt);
    if (state.timeLeft === 0 && state.mode === 'timed') {
      // evaluate winner
      let best = state.players[0];
      for (let p of state.players) if (p.coins > best.coins) best = p;
      state.winner = best;
      playBeep(440, 0.6);
    }

    coinSpawnTimer += dt;
    if (coinSpawnTimer > 2.0) {
      spawnCoin();
      coinSpawnTimer = 0;
    }
    powerupSpawnTimer -= dt;
    if (powerupSpawnTimer <= 0) {
      spawnPowerup();
      powerupSpawnTimer = 12 + Math.random()*10;
    }

    // players update
    for (let p of state.players) {
      p.update(dt, state.keys);

      // magnet effect: attract coins
      if (p.magnet > 0) {
        for (let c of state.coins) {
          const d = Math.hypot(c.x - p.x, c.y - p.y);
          if (d < 180) {
            const nx = (p.x - c.x) / d;
            const ny = (p.y - c.y) / d;
            c.x += nx * 120 * dt;
            c.y += ny * 120 * dt;
          }
        }
      }
    }

    // coin-player collisions
    for (let p of state.players) {
      for (let c of state.coins.slice()) {
        if (Math.hypot(p.x - c.x, p.y - c.y) < p.r + c.r - 4) {
          awardCoinTo(p, c);
        }
      }
    }

    // powerup collisions
    for (let pu of state.powerups.slice()) {
      for (let p of state.players) {
        if (Math.hypot(p.x - pu.x, p.y - pu.y) < p.r + pu.r - 4) {
          // apply
          if (pu.type === 'speed') p.speedBoost = 6*60; // frames
          if (pu.type === 'shield') p.shield = 6*60;
          if (pu.type === 'magnet') p.magnet = 8*60;
          // remove
          state.powerups = state.powerups.filter(x => x !== pu);
          playBeep(1000, 0.08);
          break;
        }
      }
    }

    // update coins & powerups
    for (let c of state.coins) c.update(dt);
    for (let pu of state.powerups) pu.update(dt);
    state.powerups = state.powerups.filter(pu => pu.life > 0);

    // player collisions
    handlePlayerCollisions();

    // scoring: if player has >= scoreLimit, they win round
    for (let p of state.players) {
      if (p.coins >= state.scoreLimit) {
        p.score += 1;
        // reset coins from everyone (round)
        for (let q of state.players) q.coins = 0;
        // spawn fresh coins
        state.coins = [];
        for (let i=0;i<8;i++) spawnCoin();
        playBeep(600, 0.3);
        // check if player reached overall score target (like first to 3 wins)
        // (not implemented multi-round limit â€” keep as single big race)
        // For now, announce winner if a single round target reached
        state.winner = p;
      }
    }

    // UI updates
    updatePlayerListUI();
  }

  function updatePlayerListUI(){
    for (let p of state.players) {
      const el = document.getElementById('c'+p.id);
      if (el) el.textContent = p.coins;
    }
    timeLabel.textContent = formatTime(Math.ceil(state.timeLeft));
  }

  function formatTime(s){
    const m = Math.floor(s / 60);
    const sec = s % 60;
    return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
  }

  // render
  function draw(){
    // background clear
    ctx.fillStyle = '#071427';
    ctx.fillRect(0,0,canvas.width/devicePixelRatio, canvas.height/devicePixelRatio);

    // arena grid subtle
    const step = 60;
    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.strokeStyle = '#ffffff';
    for (let x = 0; x < canvas.width/devicePixelRatio; x += step) {
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x, canvas.height/devicePixelRatio); ctx.stroke();
    }
    for (let y = 0; y < canvas.height/devicePixelRatio; y += step) {
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width/devicePixelRatio, y); ctx.stroke();
    }
    ctx.restore();

    // draw coins
    for (let c of state.coins) c.draw(ctx);

    // draw powerups
    for (let pu of state.powerups) pu.draw(ctx);

    // draw players
    for (let p of state.players) p.draw(ctx);

    // HUD overlay: top-left small
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(2,6,15,0.5)';
    ctx.fillRect(12,12,220,120);
    ctx.font = '600 14px Inter, Arial';
    ctx.fillStyle = '#dff7ea';
    ctx.fillText('Scoreboard', 22, 34);
    ctx.font = '600 12px Inter, Arial';
    for (let i=0;i<state.players.length;i++){
      const p = state.players[i];
      const y = 56 + i*22;
      ctx.fillStyle = p.color;
      ctx.fillRect(22, y-12, 12, 12);
      ctx.fillStyle = '#e6eef8';
      ctx.fillText(`${p.name}  â€”  Score: ${p.score}  Coins: ${p.coins}`, 44, y);
    }
    ctx.restore();

    // winner overlay
    if (state.winner) {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0,0,canvas.width/devicePixelRatio,canvas.height/devicePixelRatio);
      ctx.fillStyle = '#fef3c7';
      ctx.font = '900 44px Inter, Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`${state.winner.name} WINS!`, canvas.width/devicePixelRatio/2, canvas.height/devicePixelRatio/2 - 8);
      ctx.font = '600 18px Inter, Arial';
      ctx.fillStyle = '#e6eef8';
      ctx.fillText(`Score: ${state.winner.score}  â€¢  Coins: ${state.winner.coins}`, canvas.width/devicePixelRatio/2, canvas.height/devicePixelRatio/2 + 28);
      ctx.restore();
    }

    if (state.paused && !state.winner) {
      ctx.save();
      ctx.fillStyle = 'rgba(1,6,12,0.45)';
      ctx.fillRect(0,0,canvas.width/devicePixelRatio,canvas.height/devicePixelRatio);
      ctx.fillStyle = '#dff7ea';
      ctx.font = '800 40px Inter, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', canvas.width/devicePixelRatio/2, canvas.height/devicePixelRatio/2);
      ctx.restore();
    }
  }

  // main loop
  function loop(now){
    const dt = Math.min(1/30, (now - state.lastTime)/1000);
    state.lastTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // init default players
  function initDefaultPlayers(){
    if (state.players.length === 0) {
      // default 2 players
      addPlayer();
      addPlayer();
    }
  }

  initDefaultPlayers();
  resetGame();
  requestAnimationFrame(loop);

  // helpers: start audio on first interaction (some browsers require user gesture)
  function resumeAudio(){
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
    document.removeEventListener('pointerdown', resumeAudio);
    document.removeEventListener('keydown', resumeAudio);
  }
  document.addEventListener('pointerdown', resumeAudio);
  document.addEventListener('keydown', resumeAudio);
})();
</script>
</body>
</html>
